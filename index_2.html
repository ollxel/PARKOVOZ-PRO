<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Parking Map Editor</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Arial', sans-serif;
            background: #f0f0f0;
            overflow: hidden;
        }
        
        .container {
            display: flex;
            height: 100vh;
        }
        
        .editor-panel {
            width: 300px;
            background: white;
            border-right: 1px solid #ddd;
            display: flex;
            flex-direction: column;
            z-index: 1000;
            overflow-y: auto; /* Make the panel scrollable */
        }
        
        .toolbar {
            padding: 20px;
            border-bottom: 1px solid #eee;
        }
        
        .toolbar h2 {
            margin-bottom: 15px;
            font-size: 18px;
            color: #333;
        }
        
        .tool-group {
            margin-bottom: 20px;
        }
        
        .tool-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
            color: #555;
        }
        
        .tool-btn {
            display: block;
            width: 100%;
            padding: 10px;
            margin-bottom: 10px;
            background: #007bff;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
        }
        
        .tool-btn:hover {
            background: #0056b3;
        }
        
        .tool-btn.active {
            background: #28a745;
        }
        
        .canvas-container {
            flex: 1;
            padding: 20px;
            background: white;
            border-bottom: 1px solid #eee;
        }
        
        .canvas-2d {
            border: 2px solid #ddd;
            cursor: crosshair;
            background: #f8f9fa;
        }
        
        .view-container {
            flex: 1;
            position: relative;
            background: #87CEEB;
        }
        
        .view-toggle {
            position: absolute;
            top: 20px;
            right: 20px;
            z-index: 1000;
            background: rgba(0,0,0,0.7);
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 4px;
            cursor: pointer;
        }
        
        .view-toggle:hover {
            background: rgba(0,0,0,0.9);
        }
        
        #canvas3d {
            width: 100%;
            height: 100%;
        }
        
        .instructions {
            padding: 20px;
            background: #f8f9fa;
            border-top: 1px solid #eee;
            font-size: 12px;
            color: #666;
        }
        
        .instructions h3 {
            margin-bottom: 10px;
            color: #333;
        }
        
        .instructions ul {
            margin-left: 20px;
        }
        
        .instructions li {
            margin-bottom: 5px;
        }

        /* New styles for grid input mode */
        .grid-input-mode {
            display: grid;
            grid-template-columns: repeat(15, 1fr); /* 15 columns for the input */
            gap: 2px;
            margin-bottom: 10px;
            border: 1px solid #ccc;
            padding: 5px;
            background: #fdfdfd;
            max-height: 250px; /* Limit height to enable scrolling */
            overflow-y: auto;
            font-size: 12px;
            line-height: 1.2;
        }

        .grid-cell {
            width: 20px; /* Fixed width for each cell */
            height: 20px; /* Fixed height */
            display: flex;
            align-items: center;
            justify-content: center;
            background-color: #f0f0f0; /* Default background for non-parking/unknown */
            border: 1px solid #eee;
            cursor: pointer;
            font-weight: bold;
            color: #555;
            user-select: none; /* Prevent text selection */
        }

        .grid-cell.parking.free {
            background-color: #e0ffe0; /* Light green for free parking */
            color: #006400;
        }

        .grid-cell.parking.occupied {
            background-color: #ffe0e0; /* Light red for occupied parking */
            color: #8B0000;
        }

        .grid-cell.non-parking {
            background-color: #ddd; /* Gray for non-parking cells */
            color: #777;
            cursor: default; /* Not clickable for non-parking */
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="editor-panel">
            <div class="toolbar">
                <h2>Редактор парковки</h2>

                <div class="tool-group">
                    <label>Инструменты:</label>
                    <button class="tool-btn active" onclick="setTool('parking')">Парковочное место</button>
                    <button class="tool-btn" onclick="setTool('road')">Дорога</button>
                    <button class="tool-btn" onclick="setTool('building')">Здание</button>
                    <button class="tool-btn" onclick="setTool('tree')">Дерево</button>
                    <button class="tool-btn" onclick="setTool('erase')">Ластик</button>
                </div>

                <div class="tool-group">
                    <label>Файлы:</label>
                    <button class="tool-btn" onclick="importParkingMap()">Импорт JSON</button>
                    <button class="tool-btn" onclick="exportParkingMap()">Экспорт JSON</button>
                    <input type="file" id="fileInput" accept=".json" style="display:none">
                </div>

                <!-- New tool group for applying parking state -->
                <div class="tool-group">
                    <label>Состояние мест (0-свободно, 1-занято):</label>
                    <button class="tool-btn" id="toggleInputModeBtn" onclick="toggleInputMode()">Переключить на грид ввод</button>

                    <div id="jsonInputMode" style="display: block;">
                        <textarea id="parkingStateInput" rows="10" style="width: 100%; margin-bottom: 10px; font-size: 12px; font-family: monospace;"></textarea>
                    </div>

                    <div id="gridInputMode" class="grid-input-mode" style="display: none;">
                        <!-- Grid cells will be injected here by JavaScript -->
                    </div>
                    
                    <button class="tool-btn" onclick="applyParkingState()">Применить состояние</button>
                </div>
                <!-- End new tool group -->

                <div class="tool-group">
                    <button class="tool-btn" onclick="clearCanvas()">Очистить всё</button>
                    <button class="tool-btn" onclick="generateRandom()">Случайная парковка</button>
                </div>
            </div>

            <div class="canvas-container">
                <canvas id="canvas2d" class="canvas-2d" width="260" height="300"></canvas>
            </div>

            <div class="instructions">
                <h3>Инструкции:</h3>
                <ul>
                    <li>Выберите инструмент</li>
                    <li>Кликайте по области для размещения</li>
                    <li>Изменения автоматически отображаются в 3D</li>
                    <li>Используйте мышь для навигации в 3D</li>
                    <li>Введите массив массивов 0/1 для состояния парковки (например, [[0,1],[1,0]])</li>
                    <li>Используйте кнопку 'Переключить' для выбора режима ввода состояния мест.</li>
                </ul>
            </div>
        </div>

        <div class="view-container">
            <button class="view-toggle" onclick="toggleView()">Переключить вид</button>
            <div id="canvas3d"></div>
        </div>
    </div>

    <script>
        // 2D Editor Variables
        let currentTool = 'parking';
        let canvas2d, ctx2d;
        let parkingData = [];
        let gridSize = 20;
        let parkingCounter = 1; // Уникальные ID для парковочных мест

        // 3D Scene Variables
        let scene, camera, renderer, controls;
        let parkingObjects = [];

        // Input mode variables
        let currentInputMode = 'json'; // 'json' or 'grid'
        const maxGridInputRows = 15;
        const maxGridInputCols = 15;

        // Initialize
        window.onload = function() {
            init2D();
            init3D();
            generateRandom(); // Start with a random map, which calls syncDataToUI
        };

        // 2D Editor Functions
        function init2D() {
            canvas2d = document.getElementById('canvas2d');
            ctx2d = canvas2d.getContext('2d');

            canvas2d.addEventListener('click', handleCanvasClick);

            // Initialize empty grid (15 rows x 13 columns as per canvas size)
            for (let i = 0; i < 15; i++) {
                parkingData[i] = [];
                for (let j = 0; j < 13; j++) {
                    parkingData[i][j] = null;
                }
            }

            draw2D();
        }

        function handleCanvasClick(event) {
            const rect = canvas2d.getBoundingClientRect();
            const x = event.clientX - rect.left;
            const y = event.clientY - rect.top;

            const gridX = Math.floor(x / gridSize);
            const gridY = Math.floor(y / gridSize);

            // Check bounds based on actual parkingData size
            const maxGridY = parkingData.length;
            const maxGridX = parkingData.length > 0 ? parkingData[0].length : 0;


            if (gridX >= 0 && gridX < maxGridX && gridY >= 0 && gridY < maxGridY) {
                if (currentTool === 'erase') {
                    parkingData[gridY][gridX] = null;
                } else if (currentTool === 'parking') {
                    // Check if existing parking spot and toggle occupied state if it is
                    const cell = parkingData[gridY][gridX];
                    if (cell && typeof cell !== 'string' && cell.type === 'parking') {
                         // Toggle occupied state if it's already a parking spot
                        cell.occupied = !cell.occupied;
                    } else {
                         // Create a new parking spot if the cell is empty or another type
                        parkingData[gridY][gridX] = {
                            type: 'parking',
                            id: parkingCounter++,
                            occupied: false // New spots are initially free
                        };
                    }
                } else {
                    // For road, building, tree: set as string
                    parkingData[gridY][gridX] = currentTool;
                }
                draw2D();
                update3D();
                syncDataToUI(); // Keep both input fields in sync
            }
        }

        function draw2D() {
            ctx2d.clearRect(0, 0, canvas2d.width, canvas2d.height);

            // Draw grid
            ctx2d.strokeStyle = '#ddd';
            ctx2d.lineWidth = 1;
            // Draw vertical lines
            for (let i = 0; i <= (parkingData.length > 0 ? parkingData[0].length : 13); i++) {
                 ctx2d.beginPath();
                 ctx2d.moveTo(i * gridSize, 0);
                 ctx2d.lineTo(i * gridSize, canvas2d.height);
                 ctx2d.stroke();
             }
             // Draw horizontal lines
             for (let i = 0; i <= parkingData.length; i++) {
                 ctx2d.beginPath();
                 ctx2d.moveTo(0, i * gridSize);
                 ctx2d.lineTo(canvas2d.width, i * gridSize);
                 ctx2d.stroke();
             }


            // Draw objects
            for (let i = 0; i < parkingData.length; i++) {
                for (let j = 0; j < parkingData[i].length; j++) {
                    const cell = parkingData[i][j];
                    if (cell) {
                        let type = cell;
                        let isOccupied = false; // Default for non-parking types
                        let parkingId = null;

                        if (typeof cell !== 'string') {
                            // It's a parking spot object
                            type = cell.type;
                            isOccupied = cell.occupied;
                            parkingId = cell.id;
                        }

                        switch (type) {
                            case 'parking':
                                ctx2d.fillStyle = isOccupied ? '#FF5722' : '#4CAF50'; // Orange for occupied, Green for free
                                break;
                            case 'road':
                                ctx2d.fillStyle = '#757575';
                                break;
                            case 'building':
                                ctx2d.fillStyle = '#FF9800';
                                break;
                            case 'tree':
                                ctx2d.fillStyle = '#2E7D32';
                                break;
                            default:
                                ctx2d.fillStyle = '#f8f9fa'; // Default background if unknown type
                        }

                        ctx2d.fillRect(j * gridSize + 1, i * gridSize + 1, gridSize - 2, gridSize - 2);

                        // Draw ID if parking space
                        if (type === 'parking' && parkingId !== null) {
                            ctx2d.fillStyle = 'black';
                            ctx2d.font = '8px Arial';
                            ctx2d.textAlign = 'center';
                            ctx2d.fillText(
                                `P${parkingId}`,
                                j * gridSize + gridSize/2,
                                i * gridSize + gridSize/2 + 3
                            );
                        }
                    }
                }
            }
        }

        function setTool(tool) {
            currentTool = tool;
            const buttons = document.querySelectorAll('.tool-btn');
            buttons.forEach(btn => btn.classList.remove('active'));
            // Find the button for the current tool and add active class
            buttons.forEach(btn => {
                if (btn.onclick && btn.onclick.toString().includes(`setTool('${tool}')`)) {
                    btn.classList.add('active');
                }
            });
             // Make sure event target is not used if called programmatically
            if (event && event.target) {
                 event.target.classList.add('active');
            }
        }

        function clearCanvas() {
             // Determine the maximum dimensions from current data
            const maxRows = parkingData.length;
            const maxCols = parkingData.length > 0 ? parkingData[0].length : 0;

            for (let i = 0; i < maxRows; i++) {
                for (let j = 0; j < maxCols; j++) {
                    parkingData[i][j] = null;
                }
            }
            parkingCounter = 1; // Reset parking ID counter
            draw2D();
            update3D();
            syncDataToUI(); // Keep both input fields in sync
        }

        function generateRandom() {
            // Create a realistic parking layout with random occupation
            const numRows = 15;
            const numCols = 13; // Fixed size for random generation as before

            parkingData = []; // Clear existing data
            for (let i = 0; i < numRows; i++) {
                parkingData[i] = [];
                for (let j = 0; j < numCols; j++) {
                    parkingData[i][j] = null;
                }
            }
            parkingCounter = 1; // Reset parking ID counter

            // Create main road
            for (let i = 0; i < numRows; i++) {
                if (i < parkingData.length && 6 < parkingData[i].length) parkingData[i][6] = 'road';
            }

            // Create horizontal roads
            for (let j = 0; j < numCols; j++) {
                if (3 < parkingData.length && j < parkingData[3].length) parkingData[3][j] = 'road';
                if (11 < parkingData.length && j < parkingData[11].length) parkingData[11][j] = 'road';
            }

            // Add parking spots, buildings, trees
            for (let i = 0; i < numRows; i++) {
                for (let j = 0; j < numCols; j++) {
                    // Check if the cell is within bounds and not already a road
                    if (i < parkingData.length && j < parkingData[i].length && parkingData[i][j] === null) {
                        const rand = Math.random();
                        if (rand < 0.6) { // Probability for parking spot
                            parkingData[i][j] = {
                                type: 'parking',
                                id: parkingCounter++,
                                occupied: Math.random() < 0.3 // Randomly occupied
                            };
                        } else if (rand < 0.7) { // Probability for building
                            parkingData[i][j] = 'building';
                        } else if (rand < 0.8) { // Probability for tree
                            parkingData[i][j] = 'tree';
                        }
                        // Cells with rand >= 0.8 remain null (empty space/grass)
                    }
                }
            }

            draw2D();
            update3D();
            syncDataToUI(); // Keep both input fields in sync
        }

        // --- New function to apply parking state from input ---
        function applyParkingState() {
            let stateArrayToApply = [];

            if (currentInputMode === 'json') {
                const textarea = document.getElementById('parkingStateInput');
                const inputString = textarea.value.trim();

                if (!inputString) {
                    alert("Введите данные о состоянии мест.");
                    return;
                }

                try {
                    stateArrayToApply = JSON.parse(inputString);

                    if (!Array.isArray(stateArrayToApply) || !stateArrayToApply.every(row => Array.isArray(row))) {
                         alert("Неверный формат данных. Ожидается массив массивов (например, [[0,1],[1,0]]).");
                         return;
                    }
                } catch (error) {
                    console.error("Ошибка при обработке входных данных:", error);
                    alert("Ошибка при обработке входных данных. Убедитесь, что формат корректен (JSON массив массивов, например [[0,1],[1,0]]).");
                    return;
                }
            } else { // currentInputMode === 'grid'
                // Create a 2D array from the grid cells
                const gridContainer = document.getElementById('gridInputMode');
                const rows = gridContainer.children.length / maxGridInputCols; // Calculate actual rows based on children and max cols

                for (let i = 0; i < rows; i++) {
                    stateArrayToApply[i] = [];
                    for (let j = 0; j < maxGridInputCols; j++) {
                        const cellDiv = gridContainer.children[i * maxGridInputCols + j];
                        // Only read the state if it's a parking cell, otherwise null
                        if (cellDiv && cellDiv.classList.contains('parking')) {
                            stateArrayToApply[i][j] = parseInt(cellDiv.textContent);
                        } else {
                            stateArrayToApply[i][j] = null; // Represents non-parking or out of bounds for the input grid
                        }
                    }
                }
            }

            // Apply the stateArrayToApply to parkingData
            const maxRowsToProcess = Math.min(stateArrayToApply.length, parkingData.length);

            for (let i = 0; i < maxRowsToProcess; i++) {
                // Ensure parkingData[i] exists before accessing its length
                const currentParkingDataRowLength = parkingData[i] ? parkingData[i].length : 0;
                const maxColsToProcess = Math.min(stateArrayToApply[i].length, currentParkingDataRowLength);
                for (let j = 0; j < maxColsToProcess; j++) {
                    const cell = parkingData[i][j];
                    const state = stateArrayToApply[i][j];

                    if (cell && typeof cell !== 'string' && cell.type === 'parking') {
                        // Only update occupied state if the state is 0 or 1
                        if (state === 0) {
                            cell.occupied = false;
                        } else if (state === 1) {
                            cell.occupied = true;
                        }
                    }
                }
            }

            draw2D();
            update3D();
            syncDataToUI(); // Keep both input fields in sync after applying
            alert("Состояние парковочных мест обновлено!");
        }
        // --- End new function ---

        // Input mode toggle functions
        function toggleInputMode() {
            const jsonModeDiv = document.getElementById('jsonInputMode');
            const gridModeDiv = document.getElementById('gridInputMode');
            const toggleBtn = document.getElementById('toggleInputModeBtn');

            if (currentInputMode === 'json') {
                currentInputMode = 'grid';
                jsonModeDiv.style.display = 'none';
                gridModeDiv.style.display = 'grid'; 
                toggleBtn.textContent = 'Переключить на JSON ввод';
            } else {
                currentInputMode = 'json';
                jsonModeDiv.style.display = 'block';
                gridModeDiv.style.display = 'none';
                toggleBtn.textContent = 'Переключить на грид ввод';
            }
            syncDataToUI(); // Update the newly visible UI from current parkingData
        }

        function syncDataToUI() {
            const jsonTextarea = document.getElementById('parkingStateInput');
            
            // 1. Prepare data for JSON textarea: only parking spot states
            const stateArrayForJson = [];
            for (let i = 0; i < parkingData.length; i++) {
                const row = [];
                for (let j = 0; j < parkingData[i].length; j++) {
                    const cell = parkingData[i][j];
                    if (cell && cell.type === 'parking') {
                        row.push(cell.occupied ? 1 : 0);
                    } else {
                        row.push(null); // Use null for non-parking cells in the JSON output
                    }
                }
                stateArrayForJson.push(row);
            }
            jsonTextarea.value = JSON.stringify(stateArrayForJson, null, 2);

            // 2. Update Grid Input
            createOrUpdateGridInput();
        }

        function createOrUpdateGridInput() {
            const gridContainer = document.getElementById('gridInputMode');
            gridContainer.innerHTML = ''; // Clear existing cells

            for (let i = 0; i < maxGridInputRows; i++) {
                for (let j = 0; j < maxGridInputCols; j++) {
                    let cellState = null; // Default to null (unknown/non-parking)
                    let isParkingSpot = false;

                    // Check if this position exists in parkingData and is a parking spot
                    if (i < parkingData.length && j < parkingData[i].length) {
                        const cell = parkingData[i][j];
                        if (cell && cell.type === 'parking') {
                            isParkingSpot = true;
                            cellState = cell.occupied ? 1 : 0;
                        }
                    }
                    
                    const cellDiv = document.createElement('div');
                    cellDiv.classList.add('grid-cell');
                    cellDiv.dataset.row = i;
                    cellDiv.dataset.col = j;

                    if (isParkingSpot) {
                        cellDiv.classList.add('parking');
                        cellDiv.textContent = cellState;
                        if (cellState === 0) {
                            cellDiv.classList.add('free');
                        } else {
                            cellDiv.classList.add('occupied');
                        }
                        cellDiv.addEventListener('click', toggleGridCellState);
                    } else {
                        cellDiv.classList.add('non-parking');
                        cellDiv.textContent = '-'; // Represent non-parking cells
                    }
                    gridContainer.appendChild(cellDiv);
                }
            }
        }

        function toggleGridCellState(event) {
            const cellDiv = event.target;
            
            // Ensure it's a parking cell that can be toggled
            if (!cellDiv.classList.contains('parking')) {
                return;
            }

            let currentState = parseInt(cellDiv.textContent);
            
            // Toggle state: 0 becomes 1, 1 becomes 0
            let newState = (currentState === 0) ? 1 : 0;
            
            // Update visual
            cellDiv.textContent = newState;
            cellDiv.classList.remove('free', 'occupied');
            if (newState === 0) {
                cellDiv.classList.add('free');
            } else {
                cellDiv.classList.add('occupied');
            }
            // Note: parkingData is NOT updated here directly. It will be updated when applyParkingState is clicked.
            // But we should update the JSON textarea view to reflect the changes in the grid immediately
            // for better UX if the other mode is selected later.
            updateJsonTextareaFromGrid();
        }

        function updateJsonTextareaFromGrid() {
            const jsonTextarea = document.getElementById('parkingStateInput');
            const gridCells = document.querySelectorAll('#gridInputMode .grid-cell');
            const tempStateArray = Array(maxGridInputRows).fill(null).map(() => Array(maxGridInputCols).fill(null));

            gridCells.forEach(cellDiv => {
                const row = parseInt(cellDiv.dataset.row);
                const col = parseInt(cellDiv.dataset.col);
                if (cellDiv.classList.contains('parking')) {
                    tempStateArray[row][col] = parseInt(cellDiv.textContent);
                } else {
                    tempStateArray[row][col] = null;
                }
            });
            jsonTextarea.value = JSON.stringify(tempStateArray, null, 2);
        }

        // 3D Scene Functions
        function init3D() {
            const container = document.getElementById('canvas3d');

            // Scene setup
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB);

            // Camera setup
            camera = new THREE.PerspectiveCamera(75, container.clientWidth / container.clientHeight, 0.1, 1000);
            camera.position.set(15, 25, 15);
            camera.lookAt(0, 0, 0);

            // Renderer setup
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(container.clientWidth, container.clientHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            container.appendChild(renderer.domElement);

            // Controls
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.maxPolarAngle = Math.PI / 2.2;

            // Lighting
            const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(10, 20, 10);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            scene.add(directionalLight);

            // Ground
            const groundGeometry = new THREE.PlaneGeometry(50, 50);
            const groundMaterial = new THREE.MeshLambertMaterial({ color: 0x90EE90 });
            const ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2;
            ground.receiveShadow = true;
            scene.add(ground);

            // Handle window resize
            window.addEventListener('resize', onWindowResize);

            // Start render loop
            animate();
        }

        function update3D() {
            // Clear existing objects (except ground, lights, etc.)
            parkingObjects.forEach(obj => {
                 if (obj && obj.parent) { // Check if object is still in the scene
                    scene.remove(obj);
                    // Dispose geometry and materials if necessary (optional but good practice for memory)
                    if (obj.geometry) obj.geometry.dispose();
                    if (obj.material && obj.material.dispose) {
                        if (Array.isArray(obj.material)) {
                             obj.material.forEach(mat => mat.dispose());
                        } else {
                             obj.material.dispose();
                        }
                    }
                 }
            });
            parkingObjects = [];

             // Determine the effective size of the map to center the 3D view
            const maxRows = parkingData.length;
            const maxCols = parkingData.length > 0 ? parkingData[0].length : 0;

            const mapWidthUnits = maxCols * (gridSize / 10); // Approximate scale mapping 2D grid to 3D units
            const mapHeightUnits = maxRows * (gridSize / 10); // Approximate scale

            // Create 3D objects from 2D data
            for (let i = 0; i < parkingData.length; i++) {
                for (let j = 0; j < parkingData[i].length; j++) {
                    const cell = parkingData[i][j];
                     if (cell) {
                         // Center the grid around (0,0) in 3D space
                        const x = (j - maxCols / 2 + 0.5) * (gridSize / 10);
                        const z = (i - maxRows / 2 + 0.5) * (gridSize / 10);

                        let object;
                        if (typeof cell === 'string') {
                            switch (cell) {
                                case 'road':
                                    object = createRoad(x, z);
                                    break;
                                case 'building':
                                    object = createBuilding(x, z);
                                    break;
                                case 'tree':
                                    object = createTree(x, z);
                                    break;
                            }
                        } else if (cell.type === 'parking') {
                            object = createParkingSpot(x, z, cell);
                        }

                        if (object) {
                            scene.add(object);
                            parkingObjects.push(object);
                        }
                    }
                }
            }

             // Adjust camera position/lookAt if needed after map size changes (optional, current lookAt(0,0,0) works with centering)
             // camera.lookAt(0, 0, 0);
        }

        function createParkingSpot(x, z, spotData) {
            const group = new THREE.Group();
            const unitSize = gridSize / 10; // Scale factor from 2D grid to 3D units

            // Parking spot base
            const geometry = new THREE.BoxGeometry(unitSize * 0.9, unitSize * 0.05, unitSize * 0.9);
            const material = new THREE.MeshLambertMaterial({ color: 0x666666 });
            const spot = new THREE.Mesh(geometry, material);
            spot.position.set(x, unitSize * 0.025, z);
            group.add(spot);

            // Parking lines (adjusted for unitSize)
            const lineGeometry = new THREE.BoxGeometry(unitSize * 0.95, unitSize * 0.06, unitSize * 0.05);
            const lineMaterial = new THREE.MeshLambertMaterial({ color: 0xffffff });

            const line1 = new THREE.Mesh(lineGeometry, lineMaterial);
            line1.position.set(x, unitSize * 0.03, z - unitSize * 0.45); // Position along Z edge
            group.add(line1);

            const line2 = new THREE.Mesh(lineGeometry, lineMaterial);
            line2.position.set(x, unitSize * 0.03, z + unitSize * 0.45); // Position along Z edge
            group.add(line2);

            // Add a car if the spot is occupied
            if (spotData.occupied) {
                const car = createCar(unitSize); // Pass unitSize to car creation
                car.position.set(x, unitSize * 0.15, z); // Position car group center
                group.add(car); // Add car to the spot group
            }

            return group;
        }

        function createRoad(x, z) {
             const unitSize = gridSize / 10;
            const geometry = new THREE.BoxGeometry(unitSize * 0.95, unitSize * 0.04, unitSize * 0.95);
            const material = new THREE.MeshLambertMaterial({ color: 0x404040 });
            const road = new THREE.Mesh(geometry, material);
            road.position.set(x, unitSize * 0.02, z);
            return road;
        }

        function createBuilding(x, z) {
             const unitSize = gridSize / 10;
            const height = unitSize * (2 + Math.random() * 3); // Scale height too
            const geometry = new THREE.BoxGeometry(unitSize * 0.8, height, unitSize * 0.8);
            const material = new THREE.MeshLambertMaterial({ color: 0x8B4513 });
            const building = new THREE.Mesh(geometry, material);
            building.position.set(x, height / 2, z);
            building.castShadow = true;
            return building;
        }

        function createTree(x, z) {
             const unitSize = gridSize / 10;
            const group = new THREE.Group();

            // Trunk
            const trunkHeight = unitSize * 1;
            const trunkGeometry = new THREE.CylinderGeometry(unitSize * 0.05, unitSize * 0.075, trunkHeight);
            const trunkMaterial = new THREE.MeshLambertMaterial({ color: 0x8B4513 });
            const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
            trunk.position.set(x, trunkHeight / 2, z); // Position trunk base
            group.add(trunk);

            // Foliage
            const foliageRadius = unitSize * 0.4;
            const foliageGeometry = new THREE.SphereGeometry(foliageRadius);
            const foliageMaterial = new THREE.MeshLambertMaterial({ color: 0x228B22 });
            const foliage = new THREE.Mesh(foliageGeometry, foliageMaterial);
            foliage.position.set(x, trunkHeight + foliageRadius * 0.7, z); // Position foliage above trunk
            foliage.castShadow = true;
            group.add(foliage);

            return group;
        }

        function createCar(unitSize) {
            const group = new THREE.Group();

            // Body (scaled by unitSize)
            const bodyGeometry = new THREE.BoxGeometry(unitSize * 0.6, unitSize * 0.2, unitSize * 1.0); // Adjusted size
            const bodyMaterial = new THREE.MeshLambertMaterial({ color: Math.random() > 0.5 ? 0x3498db : 0xe74c3c }); // Random


            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.position.y = unitSize * 0.1;
            group.add(body);
            
            // Top of car
            const topGeometry = new THREE.BoxGeometry(unitSize * 0.4, unitSize * 0.15, unitSize * 0.6);
            const top = new THREE.Mesh(topGeometry, bodyMaterial);
            top.position.set(0, unitSize * 0.25, unitSize * 0.1);
            group.add(top);
            
            // Wheels
            const wheelGeometry = new THREE.CylinderGeometry(unitSize * 0.075, unitSize * 0.075, unitSize * 0.1, 16);
            wheelGeometry.rotateZ(Math.PI/2);
            const wheelMaterial = new THREE.MeshLambertMaterial({ color: 0x222222 });
            
            const positions = [
                [-unitSize * 0.3, unitSize * 0.05, -unitSize * 0.4], [unitSize * 0.3, unitSize * 0.05, -unitSize * 0.4],
                [-unitSize * 0.3, unitSize * 0.05, unitSize * 0.4], [unitSize * 0.3, unitSize * 0.05, unitSize * 0.4]
            ];
            
            positions.forEach(pos => {
                const wheel = new THREE.Mesh(wheelGeometry, wheelMaterial);
                wheel.position.set(...pos);
                group.add(wheel);
            });
            
            return group;
        }

        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }
        
        function onWindowResize() {
            const container = document.getElementById('canvas3d');
            camera.aspect = container.clientWidth / container.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(container.clientWidth, container.clientHeight);
        }
        
        function toggleView() {
            // Toggle between different camera angles
            const positions = [
                { x: 15, y: 25, z: 15 },
                { x: 0, y: 30, z: 0 },
                { x: 25, y: 15, z: 0 },
                { x: 0, y: 15, z: 25 }
            ];
            
            const currentPos = camera.position;
            let nextIndex = 0;
            
            for (let i = 0; i < positions.length; i++) {
                const pos = positions[i];
                if (Math.abs(currentPos.x - pos.x) < 1 && 
                    Math.abs(currentPos.y - pos.y) < 1 && 
                    Math.abs(currentPos.z - pos.z) < 1) {
                    nextIndex = (i + 1) % positions.length;
                    break;
                }
            }
            
            const newPos = positions[nextIndex];
            camera.position.set(newPos.x, newPos.y, newPos.z);
            camera.lookAt(0, 0, 0);
        }
        
        // Управление файлами
        let fileName = "parking_map";
        
        function exportParkingMap() {
            const dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(
                JSON.stringify({
                    mapData: parkingData,
                    fileName: fileName
                })
            );
            const downloadAnchor = document.createElement("a");
            downloadAnchor.setAttribute("href", dataStr);
            downloadAnchor.setAttribute("download", fileName + ".json");
            document.body.appendChild(downloadAnchor);
            downloadAnchor.click();
            downloadAnchor.remove();
        }

        function importParkingMap() {
            document.getElementById('fileInput').click();
        }

        document.getElementById('fileInput').addEventListener('change', function(event) {
            const file = event.target.files[0];
            if (!file || file.type !== "application/json") return;
            
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const jsonData = JSON.parse(e.target.result);
                    if (jsonData.mapData && Array.isArray(jsonData.mapData)) {
                        // Update fileName
                        fileName = jsonData.fileName || "imported_parking_map";
                        
                        // Update parkingData
                        parkingData = jsonData.mapData;
                        
                        // Reset the parkingCounter to the next available ID
                        let maxId = 0;
                        parkingData.forEach(row => {
                            row.forEach(cell => {
                                if (cell && cell.type === 'parking' && cell.id > maxId) {
                                    maxId = cell.id;
                                }
                            });
                        });
                        parkingCounter = maxId + 1;
                        
                        draw2D();
                        update3D();
                        syncDataToUI(); // Keep both input fields in sync
                        alert("Карта успешно импортирована!");
                    }
                } catch (error) {
                    console.error("Ошибка загрузки файла:", error);
                    alert("Неверный формат файла!");
                }
                event.target.value = ""; // Сброс выбора файла
            };
            reader.readAsText(file);
        });
    </script>
</body>
</html>